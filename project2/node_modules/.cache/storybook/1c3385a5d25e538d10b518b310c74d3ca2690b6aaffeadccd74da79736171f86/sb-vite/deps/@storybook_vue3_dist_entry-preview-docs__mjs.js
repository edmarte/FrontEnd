import {
  require_kebabCase
} from "./chunk-EV75PDG2.js";
import {
  SNIPPET_RENDERED,
  SourceType,
  convert4,
  enhanceArgTypes,
  extractComponentDescription,
  extractComponentProps,
  hasDocgen
} from "./chunk-ERDU5A6E.js";
import "./chunk-QDSJUQY7.js";
import "./chunk-NMEX6YPR.js";
import "./chunk-ZN4GUVH5.js";
import "./chunk-TBGYEO4W.js";
import "./chunk-U2IXSJNU.js";
import "./chunk-UNBGYZW7.js";
import "./chunk-MTQTFU4E.js";
import "./chunk-MGMCYDCT.js";
import "./chunk-TXZH374F.js";
import {
  baseParse,
  h,
  isVNode,
  watch
} from "./chunk-QADYYMB6.js";
import {
  require_preview_api
} from "./chunk-5SMCBIFY.js";
import "./chunk-FO3RVFIE.js";
import "./chunk-6XDG2T6T.js";
import "./chunk-TLY5536C.js";
import "./chunk-TZ3NUJRW.js";
import "./chunk-N5IYAYKF.js";
import "./chunk-PFJKRN6O.js";
import "./chunk-5TNDN7PP.js";
import "./chunk-WIITGKR3.js";
import "./chunk-QVHPBK4B.js";
import "./chunk-GMQGG7SP.js";
import "./chunk-2HBT7USK.js";
import "./chunk-E2YVGDIX.js";
import "./chunk-UZKO7U2K.js";
import "./chunk-VXDXRZQT.js";
import "./chunk-WPLYEVI3.js";
import "./chunk-RG5XE5P4.js";
import "./chunk-OTR4ELWN.js";
import {
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/@storybook/vue3/dist/entry-preview-docs.mjs
var import_preview_api = __toESM(require_preview_api(), 1);
var import_kebabCase = __toESM(require_kebabCase(), 1);
var ARG_TYPE_SECTIONS = ["props", "events", "slots", "exposed", "expose"];
var extractArgTypes = (component) => {
  if (!hasDocgen(component))
    return null;
  let usedDocgenPlugin = "exposed" in component.__docgenInfo ? "vue-component-meta" : "vue-docgen-api", argTypes2 = {};
  return ARG_TYPE_SECTIONS.forEach((section) => {
    extractComponentProps(component, section).forEach((extractedProp) => {
      let argType;
      if (usedDocgenPlugin === "vue-docgen-api") {
        let docgenInfo = extractedProp.docgenInfo;
        argType = extractFromVueDocgenApi(docgenInfo, section, extractedProp);
      } else {
        let docgenInfo = extractedProp.docgenInfo;
        argType = extractFromVueComponentMeta(docgenInfo, section);
      }
      if (!argType || argTypes2[argType.name])
        return;
      ["events", "expose", "exposed"].includes(section) && (argType.control = { disable: true }), argTypes2[argType.name] = argType;
    });
  }), argTypes2;
};
var extractFromVueDocgenApi = (docgenInfo, section, extractedProp) => {
  var _a, _b, _c;
  let type, sbType;
  if (section === "events" && (type = (_a = docgenInfo.type) == null ? void 0 : _a.names.join(), sbType = { name: "other", value: type ?? "", required: false }), section === "slots") {
    let slotBindings = (_b = docgenInfo.bindings) == null ? void 0 : _b.filter((binding) => !!binding.name).map((binding) => {
      var _a2;
      return `${binding.name}: ${((_a2 = binding.type) == null ? void 0 : _a2.name) ?? "unknown"}`;
    }).join("; ");
    type = slotBindings ? `{ ${slotBindings} }` : void 0, sbType = { name: "other", value: type ?? "", required: false };
  }
  if (section === "props") {
    let propInfo = docgenInfo;
    if (type = (_c = propInfo.type) == null ? void 0 : _c.name, sbType = extractedProp ? convert4(extractedProp.docgenInfo) : { name: "other", value: type }, propInfo.type && "elements" in propInfo.type && Array.isArray(propInfo.type.elements) && propInfo.type.elements.length > 0) {
      let elements = propInfo.type.elements.map((i) => i.name);
      type === "Array" && (type = `${elements.length === 1 ? elements[0] : `(${elements.join(" | ")})`}[]`), type === "union" ? type = elements.join(" | ") : type === "intersection" && (type = elements.join(" & "));
    }
  }
  let required = "required" in docgenInfo ? docgenInfo.required ?? false : false;
  return { name: docgenInfo.name, description: docgenInfo.description, type: sbType ? { ...sbType, required } : { name: "other", value: type ?? "" }, table: { type: type ? { summary: type } : void 0, defaultValue: extractedProp == null ? void 0 : extractedProp.propDef.defaultValue, jsDocTags: extractedProp == null ? void 0 : extractedProp.propDef.jsDocTags, category: section } };
};
var extractFromVueComponentMeta = (docgenInfo, section) => {
  if ("global" in docgenInfo && docgenInfo.global)
    return;
  let tableType = { summary: docgenInfo.type.replace(" | undefined", "") };
  if (section === "props") {
    let propInfo = docgenInfo, defaultValue = propInfo.default ? { summary: propInfo.default } : void 0;
    return { name: propInfo.name, description: formatDescriptionWithTags(propInfo.description, propInfo.tags), defaultValue, type: convertVueComponentMetaProp(propInfo), table: { type: tableType, defaultValue, category: section } };
  } else
    return { name: docgenInfo.name, description: "description" in docgenInfo ? docgenInfo.description : "", type: { name: "other", value: docgenInfo.type }, table: { type: tableType, category: section } };
};
var convertVueComponentMetaProp = (propInfo) => {
  var _a, _b;
  let schema = propInfo.schema, required = propInfo.required, fallbackSbType = { name: "other", value: propInfo.type, required }, KNOWN_SCHEMAS = ["string", "number", "function", "boolean", "symbol"];
  if (typeof schema == "string")
    return KNOWN_SCHEMAS.includes(schema) ? { name: schema, required } : fallbackSbType;
  switch (schema.kind) {
    case "enum": {
      let definedSchemas = ((_a = schema.schema) == null ? void 0 : _a.filter((item) => item !== "undefined")) ?? [];
      return isBooleanSchema(definedSchemas) ? { name: "boolean", required } : isLiteralUnionSchema(definedSchemas) || isEnumSchema(definedSchemas) ? { name: "enum", value: definedSchemas.map((literal) => literal.replace(/"/g, "")), required } : definedSchemas.length === 1 ? convertVueComponentMetaProp({ schema: definedSchemas[0], type: propInfo.type, required }) : (definedSchemas.length > 2 && definedSchemas.includes("true") && definedSchemas.includes("false") && (definedSchemas = definedSchemas.filter((i) => i !== "true" && i !== "false"), definedSchemas.push("boolean")), { name: "union", value: definedSchemas.map((i) => convertVueComponentMetaProp(typeof i == "object" ? { schema: i, type: i.type, required: false } : { schema: i, type: i, required: false })), required });
    }
    case "array": {
      let definedSchemas = ((_b = schema.schema) == null ? void 0 : _b.filter((item) => item !== "undefined")) ?? [];
      return definedSchemas.length === 0 ? fallbackSbType : definedSchemas.length === 1 ? { name: "array", value: convertVueComponentMetaProp({ schema: definedSchemas[0], type: propInfo.type, required: false }), required } : { name: "union", value: definedSchemas.map((i) => convertVueComponentMetaProp(typeof i == "object" ? { schema: i, type: i.type, required: false } : { schema: i, type: i, required: false })), required };
    }
    case "object":
      return { name: "object", value: Object.entries(schema.schema ?? {}).reduce((obj, [propName, propSchema]) => (obj[propName] = convertVueComponentMetaProp(propSchema), obj), {}), required };
    default:
      return fallbackSbType;
  }
};
var formatDescriptionWithTags = (description, tags) => !(tags == null ? void 0 : tags.length) || !description ? description ?? "" : `${tags.map((tag) => `@${tag.name}: ${tag.text}`).join("<br>")}<br><br>${description}`;
var isLiteralUnionSchema = (schemas) => schemas.every((schema) => typeof schema == "string" && schema.startsWith('"') && schema.endsWith('"'));
var isEnumSchema = (schemas) => schemas.every((schema) => typeof schema == "string" && schema.includes("."));
var isBooleanSchema = (schemas) => schemas.length === 2 && schemas.includes("true") && schemas.includes("false");
var omitEvent = (args2) => args2 ? Object.fromEntries(Object.entries(args2).filter(([key, value]) => !key.startsWith("on"))) : {};
var displayObject = (obj) => obj && typeof obj == "object" ? `{${Object.keys(obj).map((key) => `${key}:${displayObject(obj[key])}`).join(",")}}` : typeof obj == "string" ? `'${obj}'` : obj == null ? void 0 : obj.toString();
var htmlEventAttributeToVueEventAttribute = (key) => /^on[A-Za-z]/.test(key) ? key.replace(/^on/, "v-on:").toLowerCase() : key;
var directiveSource = (key, value) => key.toLowerCase().startsWith("on") ? `${htmlEventAttributeToVueEventAttribute(key)}='()=>({})'` : `${key}="${value || ""}"`;
var attributeSource = (key, value, dynamic) => ["boolean", "number", "object"].includes(typeof value) || dynamic && ["style", "class"].includes(key) ? `:${key}="${displayObject(value)}"` : directiveSource(key, value);
var evalExp = (argExpValue, args2) => {
  let evalVal = argExpValue;
  return evalVal && /v-bind="(\w+)"/.test(evalVal) ? evalVal.replace(/"(\w+)"/g, `"${displayObject(args2)}"`) : (Object.keys(args2).forEach((akey) => {
    let regexMatch = new RegExp(`(\\w+)\\.${akey}`, "g"), regexTarget = new RegExp(`(\\w+)\\.${akey}`, "g");
    regexMatch.test(evalVal) && (evalVal = evalVal.replace(regexTarget, displayObject(args2[akey])));
  }), evalVal);
};
var replaceValueWithRef = (source2, args2, ref) => {
  let value = ref ? args2[ref] : "args", bindValue = () => {
    let argsRef = Object.fromEntries(Object.entries(args2).map(([key]) => [key, key]));
    return displayObject(argsRef).replace(/'/g, "");
  }, regexMatch = new RegExp(`="${value}"`, "g");
  return source2.replace(regexMatch, `="${ref ?? bindValue()}"`);
};
function generateExpression(slot) {
  let body = slot.toString().split("=>")[1].trim().replace("return", "").trim();
  return body.startsWith("{") && body.endsWith("}") && (body = body.substring(1, body.length - 1).trim()), `{{${body}}}`;
}
var skipSourceRender = (context) => {
  var _a;
  let sourceParams = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source, isArgsStory = context == null ? void 0 : context.parameters.__isArgsStory, isDocsViewMode = (context == null ? void 0 : context.viewMode) === "docs";
  return (sourceParams == null ? void 0 : sourceParams.type) === SourceType.DYNAMIC ? false : !isDocsViewMode || !isArgsStory || (sourceParams == null ? void 0 : sourceParams.code) || (sourceParams == null ? void 0 : sourceParams.type) === SourceType.CODE;
};
function generateAttributesSource(tempArgs, args2, argTypes2, byRef2) {
  return Object.keys(tempArgs).map((key) => {
    var _a;
    let source2 = tempArgs[key].loc.source.replace(/\$props/g, "args"), argKey = (_a = tempArgs[key].arg) == null ? void 0 : _a.loc.source;
    return byRef2 && argKey ? replaceValueWithRef(source2, args2, argKey) : evalExp(source2, omitEvent(args2));
  }).join(" ");
}
function mapAttributesAndDirectives(props) {
  let tranformKey = (key) => key.startsWith("on") ? key : (0, import_kebabCase.default)(key);
  return Object.keys(props).map((key) => ({ name: "bind", type: ["v-", "@", "v-on"].includes(key) ? 7 : 6, arg: { content: tranformKey(key), loc: { source: tranformKey(key) } }, loc: { source: attributeSource(tranformKey(key), props[key]) }, exp: { isStatic: false, loc: { source: props[key] } }, modifiers: [""] }));
}
function mapSlots(slotsArgs, generateComponentSource2, slots) {
  return Object.keys(slotsArgs).map((key) => {
    var _a, _b;
    let slot = slotsArgs[key], slotContent = "", scropedArgs = (_b = (_a = slots.find((s) => s.name === key && s.scoped)) == null ? void 0 : _a.bindings) == null ? void 0 : _b.map((b) => b.name).join(",");
    typeof slot == "string" ? slotContent = slot : typeof slot == "function" ? slotContent = generateExpression(slot) : isVNode(slot) ? slotContent = generateComponentSource2(slot) : typeof slot == "object" && !isVNode(slot) && (slotContent = JSON.stringify(slot));
    let bindingsString = scropedArgs ? `="{${scropedArgs}}"` : "";
    return slotContent = slot ? `<template #${key}${bindingsString}>${slotContent}</template>` : "", { type: 2, content: slotContent, loc: { source: slotContent, start: { offset: 0, line: 1, column: 0 }, end: { offset: 0, line: 1, column: 0 } } };
  });
}
function generateScriptSetup(args2, argTypes2, components) {
  let scriptLines = Object.keys(args2).map((key) => `const ${key} = ${typeof args2[key] == "function" ? "()=>{}" : `ref(${JSON.stringify(args2[key])});`}`);
  return scriptLines.unshift('import { ref } from "vue";'), `<script lang='ts' setup>${scriptLines.join(`
`)}<\/script>`;
}
function getTemplateComponents(renderFn, context) {
  try {
    let originalStoryFn = renderFn, storyFn = originalStoryFn ? originalStoryFn(context == null ? void 0 : context.args, context) : context == null ? void 0 : context.component, story = typeof storyFn == "function" ? storyFn() : storyFn, { template } = story;
    return template ? getComponents(template) : [h(story, context == null ? void 0 : context.args)];
  } catch {
    return [];
  }
}
function getComponents(template) {
  var _a;
  let components = (_a = baseParse(template, { isNativeTag: () => true, decodeEntities: (rawtext, asAttr) => rawtext })) == null ? void 0 : _a.children;
  return components || [];
}
function generateTemplateSource(componentOrNodes, { args, argTypes }, byRef = false) {
  let isElementNode = (node) => node && node.type === 1, isInterpolationNode = (node) => node && node.type === 5, isTextNode = (node) => node && node.type === 2, generateComponentSource = (componentOrNode) => {
    var _a, _b;
    if (isElementNode(componentOrNode)) {
      let { tag: name, props: attributes, children } = componentOrNode, childSources = typeof children == "string" ? children : children.map((child) => generateComponentSource(child)).join(""), props = generateAttributesSource(attributes, args, argTypes, byRef);
      return childSources === "" ? `<${name} ${props} />` : `<${name} ${props}>${childSources}</${name}>`;
    }
    if (isTextNode(componentOrNode)) {
      let { content: content2 } = componentOrNode;
      return content2;
    }
    if (isInterpolationNode(componentOrNode)) {
      let { content } = componentOrNode, expValue = evalExp(content.loc.source, args);
      return expValue === content.loc.source ? `{{${expValue}}}` : eval(expValue);
    }
    if (isVNode(componentOrNode)) {
      let vnode = componentOrNode, { props, type, children } = vnode, slotsProps = typeof children == "string" ? void 0 : children, componentSlots = (_a = type == null ? void 0 : type.__docgenInfo) == null ? void 0 : _a.slots, attrsProps = slotsProps ? Object.fromEntries(Object.entries(props ?? {}).filter(([key, value]) => !slotsProps[key] && !["class", "style"].includes(key)).map(([key, value]) => [key, value])) : props, attributes = mapAttributesAndDirectives(attrsProps ?? {}), slotArgs = Object.fromEntries(Object.entries(props ?? {}).filter(([key, value]) => slotsProps == null ? void 0 : slotsProps[key])), childSources = children ? typeof children == "string" ? children : mapSlots(slotArgs, generateComponentSource, componentSlots ?? []).map((child) => child.content).join("") : "", name = typeof type == "string" ? type : type.name || type.__name || ((_b = type.__docgenInfo) == null ? void 0 : _b.displayName), propsSource = generateAttributesSource(attributes, args, argTypes, byRef);
      return childSources.trim() === "" ? `<${name} ${propsSource}/>` : `<${name} ${propsSource}>${childSources}</${name}>`;
    }
    return null;
  }, componentsOrNodes = Array.isArray(componentOrNodes) ? componentOrNodes : [componentOrNodes], source = componentsOrNodes.map((componentOrNode2) => generateComponentSource(componentOrNode2)).join(" ");
  return source || null;
}
var sourceDecorator = (storyFn, context) => {
  let skip = skipSourceRender(context), story = storyFn();
  return watch(() => context.args, () => {
    skip || generateSource(context);
  }, { immediate: true, deep: true }), story;
};
function generateSource(context) {
  var _a, _b, _c;
  let channel = import_preview_api.addons.getChannel(), { args: args2 = {}, argTypes: argTypes2 = {}, id } = context || {}, storyComponents = getTemplateComponents(context == null ? void 0 : context.originalStoryFn, context), withScript = ((_c = (_b = (_a = context == null ? void 0 : context.parameters) == null ? void 0 : _a.docs) == null ? void 0 : _b.source) == null ? void 0 : _c.withScriptSetup) || false, generatedScript = withScript ? generateScriptSetup(args2) : "", generatedTemplate = generateTemplateSource(storyComponents, context, withScript);
  if (generatedTemplate) {
    let source2 = `${generatedScript}
 <template>
 ${generatedTemplate} 
</template>`;
    return channel.emit(SNIPPET_RENDERED, { id, args: args2, source: source2, format: "vue" }), source2;
  }
  return null;
}
var parameters = { docs: { story: { inline: true }, extractArgTypes, extractComponentDescription } };
var decorators = [sourceDecorator];
var argTypesEnhancers = [enhanceArgTypes];
export {
  argTypesEnhancers,
  decorators,
  parameters
};
//# sourceMappingURL=@storybook_vue3_dist_entry-preview-docs__mjs.js.map
